<!doctype html>
<html lang="{{ metadata.language }}">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="/assets/reveal/reveal.css" />
  <link rel="stylesheet" href="/assets/reveal/theme/dracula.css" />
  <link rel="stylesheet" href="/assets/reveal/plugin/highlight/monokai.css">
  <link rel="stylesheet" href="./kbd.min.css" />
  <title>Testing testing gotta get down on testing - VanJS - July 16th, 2025</title>
  <style>
    figure {
      display: block;
    }

    figcaption {
      text-align: center
    }

    ul {
      width: 100%;
    }

    .row {
      display: flex
    }

    .column {
      flex: 1;
      margin-right: 10px;
    }
  </style>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <img class="r-stretch" src="./gottagetdown.jpg" alt="Testing testing gotta get down on testing" />
        <h2>VanJS</h2>
        <h3>July 16th, 2025</h3>
      </section>
      <section>
        <h2>Gavin Mogan</h2>
        <p>
          Senior Software Engineer at Digital Ocean.
          <img src="./Sammy08.png" alt="Digital Ocean Mascot, Sammy the Shark, holding a heart ballon" width="100"
            style="vertical-align: middle;" />
        </p>
        <p><a href="https://www.gavinmogan.com">https://www.gavinmogan.com</a></p>
        <p>
        <div style="position: relative">
          <img class="r-stretch" src="./avatar.original.png" alt="Avatar" width="400"
            alt="photo of child gavin in 1982 sitting infront of a computer at the time" />
        </div>
        </p>
        <aside class="notes">
          Hey everyone,
          I'm Gavin. I am a Senior Software Developer at Digital Ocean, currently on the billing team doing backend
          golang work. I don't really get to do javascript that much anymore, but I've been coming to vanjs since the
          before times and as a huge fan I love to give back... </aside>
      </section>
      <section>
        <h2>Testing?</h2>
        <blockquote cite="https://www.merriam-webster.com/dictionary/test" style="text-align: left">
          <p>means of testing: such as</p>
          <p>(1) something (such as a series of questions or exercises) for measuring the skill, knowledge,
            intelligence,
            capacities, or aptitudes of an individual or group</p>
          <p>(2) a procedure, reaction, or reagent used to identify or characterize a substance or constituent</p>
        </blockquote>
        <p>&mdash; <cite>Merriam Webster</cite></p>
        <aside class="notes">
          So what am I here to talk about today? Well Miram Webster defines test as a means of testing

          ...

          Just kidding, not only is that confusing, but i'm not going to do a highschool style presentation.
        </aside>
      </section>
      <section>
        <h2>Why should you listen to me?</h2>
        <ul>
          <li>You probably shouldn't.</li>
          <li>I've made so many mistakes so you don't have to.</li>
          <li>Worked at several testing compainies.</li>
          <li>Was on the board for the open source project Jenkins.</li>
          <li>Been interviewed about testing on podcasts.</li>
        </ul>
        <aside class="notes">
          So... why should you listen to me?

          <p>You probably shouldn't. There are a lot of paid experts out there that probably have much saner advice, but
            that being said, I have made so many mistakes over my long career that I know whats not to do.</p>

          <p>I've also worked at several saas companies that sell testing related services, tooling and
            products. I've had plenty of exposure to all the good stuff. I was on the board of the open source project
            Jenkins, which I believe still heavily used to run tests,
            though I wont be talking about it today.</p>
        </aside>
      </section>
      <section>
        <h2>What is testing?</h2>
        <figure>
          <img src="./testing-pyramid-placeholder.png" style="max-height: 50vh" />
          <figcaption>Produced by ChatGPT</figcaption>
        </figure>
        <aside class="notes">
          <p>So I was going to put up a diagram of the testing pyramid and tell ya all how I didn't agree with all the
            steps, but apparently I misremembered and there's no standard.</p>
        </aside>
      </section>
      <section>
        <figure>
          <img src="./testing-pyramid.png" style="max-height: 50vh" />
          <figcaption>&mdash; <a href="https://martinfowler.com/articles/practical-test-pyramid.html">The Practical Test
              Pyramid - Martin Fowler</a>
          </figcaption>
        </figure>
        <aside class="notes">
          <p>The closest to official one I could find is this one by martin fowler which says you should have the least
            amount of ui or integration tests, and the most of unit tests</p>
        </aside>
      </section>
      <section>
        <h2>Gavin's testing pyramid?</h2>
        <ul>
          <li>End To End (e2e) tests (aka integration).</li>
          <li>Mock e2e tests.</li>
          <li>"Simple" tests.</li>
        </ul>
        <aside class="notes">
          <p>So gavin version. I'll go into details but in order from most expensive, to cheapest... End to end tests.
            End
            to end tests but with mocks... So not end to end and lastly Unit tests. There are more types, but this is
            what I usually go by.</p>
          <p>The idea is to have the least of the first and the most of the last, as they are fastest and easiest to
            isolate.</p>
        </aside>
      </section>
      <section>
        <h2>End to End Tests</h2>
        <p>"everything real"</p>
        <ul>
          <li>Actual Client (Browser)</li>
          <li>Actual Server</li>
          <li>Real Credentials</li>
          <li>Actual Database</li>
        </ul>
        <h3>Examples</h3>
        <ul>
          <li>Entire application</li>
        </ul>
        <aside class="notes">
          Everything real.
          :read list:
          While fully testing in a perfect production environt is hard to actually achieve, you can
          often get pretty close.
          Try to keep the environment as close as you can. We use use stripe test credentials so we can test scenarios
          with test credit cards. Sometimes have the ips
          added to an allow list so they don't get rate limited.
        </aside>
      </section>
      <section>
        <h2>E2E Strengths</h2>
        <ul>
          <li>Makes sure everything works together</li>
          <li>Closest to end-user behaviors</li>
          <li>External changes get highlighted</li>
        </ul>
        <aside class="notes">
          Strengths... the goal is to test the whole system. So make sure everything works together. Api responses. UI
          responses.
          If another system changes something slightly, like json returning string instead of integer, it'll get
          highlighted in this setup.
        </aside>
      </section>
      <section>
        <h2>E2E Weaknesses</h2>
        <ul>
          <li>Hard to setup and control state</li>
          <li>Slowest</li>
          <li>Flakey</li>
        </ul>
        <aside class="notes">
          <p>Since you are doing everything with real behaviors, it can be tricker to create or reset states. You can't
            just change runtime variables without adding admin apis or connecting to dbs
          <p>
          <p>Slowest - Usually need to do remote calls like db or api or browser</p>
          <p>Flakey - Since you have less control you look for strings or colors</p>
          <p>Flakey - Small external changes can break things</p>
        </aside>
      </section>
      <section>
        <h2>E2E Tools</h2>
        <div class="row">
          <div class="column">
            <h3>Browser</h3>
            <ul>
              <li>Playwright</li>
              <li>Cypress</li>
              <li>Selenium</li>
              <li>TestCafe</li>
            </ul>
          </div>
          <div class="column">
            <h3>Mobile</h3>
            <ul>
              <li>Appium</li>
            </ul>
          </div>
          <div class="column">
            <h3>Visual</h3>
            <ul>
              <li>Chromatic</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          I'll admit, I don't have a lot of knowledge in this space as I'm no longer doing frontend development full
          time.
          The last new hotness I've heard about is playwright. I've heard its good fast and reliable, but I'm guessing
          there's lots here who know more than me.
          Reading up on testcafe, it seems it uses client side javascript to control the browser, which means it should
          let you test on anything that can run javascript.
          I'm also mentioning appium as a couple of my friends created and maintain it.
        </aside>
      </section>

      <section>
        <h2>Mocked E2E Tests</h2>
      </section>

      <section>
        <h2>Mocked E2E Tests</h2>
        <p>A hybrid model between full e2e and isolated testing.</p>
        <p>Call mocks or fake endpoints to emulate.</p>
        <p>Bigger units of work, but also more control.</p>
        <h3>Examples</h3>
        <ul>
          <li>Login Form</li>
          <li>REST server endpoint</li>
        </ul>
        <aside class="notes">
          Mocked e2e tests is the sweet spot I end up using more than I probably should.
          I'll have a real database setup, but i'll mock out external systems like stripe to keep some control.
        </aside>
      </section>

      <section>
        <h2>Mocked - Strengths</h2>
        <ul>
          <li>Can control states</li>
          <li>Easy to spot new dependencies</li>
        </ul>
        <aside class="notes">
          <p>With using mocks and stubs and factories and all the other terms, you have a lot more control. For example,
            instead of setting up a new user, marking them as abuse, and then trying to login. With mocks you can just
            tell the user service to return a user in the right state.</p>
          <p>And with most mocking libraries, they can yell at you when your code starts to connect to unmocked systems
            or endpoints</p>
        </aside>
      </section>

      <section>
        <h2>Mocked - Cons</h2>
        <ul>
          <li>Have to implement and maintain mocks or sample data</li>
          <li>Can lead to complex mocks that dont actually test things</li>
          <li>Can easily break if your code uses globals</li>
          <li>Can hide external systems changing</li>
        </ul>
        <aside class="notes">
        </aside>
      </section>

      <section>
        <h2>Mocked - Tools</h2>
        Probably can include most e2e and unit test suites too
        <div class="row">
          <div class="column">
            <h3>Javascript</h3>
            <ul>
              <li>Nock</li>
              <li>Jest</li>
              <li>Sinon</li>
              <li>Mock Service Worker</li>
            </ul>
          </div>
          <div class="column">
            <h3>Golang</h3>
            <ul>
              <li>Gomock</li>
              <li>Counterfeiter</li>
              <li>Mockery</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          <p>I've listed out a few tools I've used, and a few I found out about in prep for this.</p>
          <p>Nock has always been an under utilalized tool. I don't know if it will work in browsers, but its great in
            express and nodejs. You can just target specific http requests and mock out responses. It can yell if the
            targets arn't found.</p>
          <p>Jest is a pretty big industry standard these days. Its not only a whole testing framework, but can provide
            mocks too</p>
          <p>Sinon has been around forever, and for good reasons. Its mocks are straight forward and reliable</p>
          <p>Mock service worker is one I just learned about, it sounds like its nock, but for browsers</p>
        </aside>
      </section>

      <section>
        <h2>"Regular"/"Unit" tests</h2>
        <p>Focus on small units of work.</p>
        <p>Make them fast, and have a ton of them</p>
        <h3>Examples</h3>
        <ul>
          <li>Sum function</li>
          <li>Convert one data model to another</li>
          <li>Password strength component</li>
        </ul>
        <aside class="notes">
          Lastly we have what I'll call unit tests. Officially they should only ever test a single function, or single
          unit of work, but with react that can get a bit complicated. The main thing is they shouldn't be testing
          anything it doesn't own. So no database, rest, graphql or anything else.
        </aside>
      </section>

      <section>
        <h2>Unit Tests - Strengths</h2>
        <ul>
          <li>Fast</li>
          <li>Just focus on input and output</li>
          <li>Easy to write</li>
          <li>Easy to maintain</li>
          <li>Can be run in parallel (unless you use globals ðŸ˜­)</li>
          <li>Indirectly can lead to maintainable and understandable code</li>
        </ul>
        <aside class="notes">
          Since unit tests are not interfacing with any other systems, they are usually the most fast. You pass in some
          inputs, and you check the outputs, you don't need to wait.

          Because of this, the more practice you get with them, the more you want your functions to work in that way. So
          for normal functions you can probably figure out how that works, just have parameters. But for things like a
          react component, that means you want to have attributes not hooks. Have the hooks outside the component at the
          integration level.

          Then quickly you start writing functions and units that are small and do like one thing. It takes a while, and
          I'll def go over how to do that later, but it does help.
        </aside>
      </section>

      <section>
        <h2>Unit Tests - Cons</h2>
        <ul>
          <li>Doesnt break when external systems change</li>
          <li>Devevelopment before testing often involves coming back and redoing development to make it testable</li>
          <li>Globals can make it hard to isolate</li>
        </ul>
        <aside class="notes">
          The main downside is because you are testing inputs and outputs, there's no indication when external systems
          change the inputs. In truth it shouldn't matter because you should have other tests that test those things,
          but it is a gap here.

          Also globals can make things really hard to test. If you use like a window dot location, or a process dot env,
          since they are not passed in as inputs, you can't really control them or parallelize without issues.

          Both are probably good reasons to refactor though.
        </aside>
      </section>

      <section>
        <h2>Unit Tests - Tools</h2>
        A very non exhaustive list
        <div class="row">
          <div class="column">
            <h3>Javascript</h3>
            <ul>
              <li>Jest</li>
              <li>Mocha</li>
              <li>Jasmine</li>
            </ul>
          </div>
          <div class="column">
            <h3>Golang</h3>
            <ul>
              <li>Go test</li>
            </ul>

            <h3>Python</h3>
            <ul>
              <li>Py.test</li>
              <li>pyunit</li>
            </ul>
          </div>
          <div class="column">
            <h3>Ruby</h3>
            <ul>
              <li>rspec</li>
            </ul>
          </div>
        </div>
        <aside class="notes">I tried to list all I could think of, but dont worry, they all more or less work the same
          way</aside>
      </section>


      <section>
        <h1>Getting Started</h1>
        <aside class="notes">So I got started with testing long before I knew what formal testing was. My first job was
          working directly on clients servers, live, with no backups. It was awful. So i got in the habit of isolating
          what I was working on so I could run a simplified version on my own computer first. </aside>
      </section>

      <section>
        <h2>Getting started pt2</h2>
        <p>You don't need a formal framework</p>
        <pre><code data-trim data-noescape>
            const Users = require('./models/users.js');

            Users.createUser({
            &nbsp;&nbsp;username => "zoidberg",
            &nbsp;&nbsp;password => "doctor"
            }).then(function(user) {
            &nbsp;&nbsp;console.log($user);
            });
          </code></pre>
        <aside class="notes">Its totally fine, especially for your own projects, just to do things like this. Create a
          file that imports your functionality and runs that. The only difference between that and a official test is
          the frameworks to get it running.
          So start there. Get in the habit. See the benefits.
        </aside>
      </section>

      <section>
        <h2>Getting started pt3</h2>
        <p><s>Testing every scenario</s></p>
        <aside class="notes">
          I think the biggest pitfall to get testing started is that people try to do everything at once. Its okay that
          your test only checks the "everything was done right" path.
          There's nothing wrong with that. Testing is an investment in the future. You can and should add more over
          time, but one test is so much better than no tests.
        </aside>
      </section>

      <section>
        <h2>Start with bugs</h2>
        <ul>
          <li>Already include reproduction steps</li>
          <li>Already need to have a way to say its done</li>
        </ul>
        <aside class="notes">
          So my suggestion, if you arn't going to do tests with development, is to setup tests when you get bug reports,
          sure start with the simple ones, but start there.
          A good bug report will have repoduction steps, so you can design the scenario, and by reproducing the bug,
          you understand the bug. Ideally you start with your test failing in that scenario.
          Then you fix the problem. Now your test should show the problem is fixed.

          Yay! you just did test driven development (sorta).

          But all you are saying is this very exact scenario won't happen again. You don't need to do more than that.
          It'll come over time
        </aside>
      </section>

      <section>
        <h2>Getting Started for real</h2>
        <h2>Aka frameworks and automation</h2>
        <aside class="notes">Okay, how do you get ready for real?</aside>
      </section>

      <section>
        <h2>Install tooling</h2>
        <pre><code data-trim data-noescape class="language-bash">
            $ npm install --save-dev jest
          </code></pre>
        <aside class="notes">
          So i'm going to be using jest for my examples. Its from facebook and has really good documentation and
          tuturoais.
          So first step is install jest into your project.
        </aside>
      </section>

      <section>
        <h3>sum.test.js</h3>
        <pre><code data-trim data-noescape class="language-javascript">
            const sum = (a, b) => a+b;

            test('adds 1 + 2 to equal 3', () => {
            &nbsp;&nbsp;expect(sum(1, 2)).toBe(3);
            })
          </code></pre>
        <pre><code data-trim data-noescape class="language-bash">
            $ jest sum.test.js
          </code></pre>
        <aside class="notes">
          Second is to create a test function, run your function, and check the output.
          Lots of javascript frameworks are nice because they try to make things readable as english.
          Expect something to be something else.
        </aside>
      </section>

      <section>
        <h3>Success!</h3>
        <pre><code data-trim data-noescape class="language-bash">
            $ jest sum.test.js
          </code></pre>
        <figure>
          <img src="./jest-output.png" alt="Jest output showing the test passed" />
        </figure>
        <aside class="notes">
          Lastly run the test. With jest it should just be jest and then your filename or directory. Most other
          frameworks work the same way.
        </aside>
      </section>

      <section>
        <h2>Automate it!</h2>
        <div class="row">
          <div class="column">
            <h3>Code Servers</h3>
            <ul>
              <li>Commit hooks</li>
              <li><a href="https://github.com/halkeye/demo-jest-github-actions">Github</a> / Gitlab actions</li>
            </ul>
          </div>
          <div class="column">
            <h3>SaaS</h3>
            <ul>
              <li>Circle CI</li>
              <li>Cloudbees (Jenkins)</li>
            </ul>
          </div>
          <div class="column">
            <h3>Self-Hosted</h3>
            <ul>
              <li>Jenkins</li>
              <li>Tekton</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          Again, just some of the tooling I know about. As I was employed by cloudbees and worked on jenkins, I've made
          sure to include it, but I almost exclusively use github actions for my own things and at work these days.
        </aside>
      </section>

      <section>
        <h3>Github Actions</h3>
        <figure>
          <img src="./github-actions.png" alt="Github actions showing a test run" />
          <figcaption><a
              href="https://github.com/halkeye/demo-jest-github-actions/actions/runs/16254522455/job/45888756590">https://github.com/halkeye/demo-jest-github-actions</a>
          </figcaption>
        </figure>
        <aside class="notes">
          As future me is sure he's out of time by now, just a quick screenshot of github actions
        </aside>
      </section>

      <section>
        <h1>The End</h1>
      </section>

      <section>
        <h2>Gavin Mogan</h2>
        <p>
          Senior Software Engineer at Digital Ocean.
          <img src="./Sammy08.png" alt="Digital Ocean Mascot, Sammy the Shark, holding a heart ballon" width="100"
            style="vertical-align: middle;" />
        </p>
        <p><a href="https://www.gavinmogan.com">https://www.gavinmogan.com</a></p>
        <p>
        <div style="position: relative">
          <img class="r-stretch" src="./avatar.original.png" alt="Avatar" width="400"
            alt="photo of child gavin in 1982 sitting infront of a computer at the time" />
        </div>
        </p>
      </section>
      <!--
What is testing?
---
What kinds of tests? - In my opinion there are only two types that matter, integration and non integration tests. Most people will call non integration tests unit tests, but thats not totally accurate.

Integration tests are tests that test the system as a whole, or at least a large part of it. They are often slower, but they give you confidence that the system works as a whole.
Unit tests test a small unit of work. From a purist point of view, a unit test can't call other functions, just its own small set of work.

in reality, the term in way more broad. I would say its anything that isn't an integration test is a unit test, and try to avoid mocking as much as possible for unit tests.

So I would say there's three. E2E integration tests, mocked integration tests, and unit tests.

So what are unit tests?
<next slide>

----

How do I get started?

I would say focus on isolating before worying about anything formal. In react this might mean make a new route that just has your component on it with hardcoded values. This allows you to create a scenario without worrying about how to get there.
If you are doing a rest interface. You can do the same with a new route.
The premise is still the same for scripts or libraries or anything else.

That gets you in the habit of thinking about creating smaller units of work.

For example, lets say you have a login form in react. It has two input fields and one button. Sounds small and simple right? But in reality it gets hard to setup an example
You need to make sure the username gets filled out, then make sure the password gets filled out, then click on the button, oh wait you need to check if the password field has stars instead of text, okay click the button, wait now the form submitted, did it work?
That gets really complicated really fast.

Instead lets break it down.
Start with just the username component. Set the value using the value attribute. Refresh. Does the value show up? You have a test case
:fireworks:

Cool we are done right? Its time to go home?

Well..... kinda. I still do this kind of thing a lot, especially when i'm thinking to myself or rubber ducking. Just want to see what if.
------- Show react testing utils to render then fill out value, then check render
--- Talk about mocks in general
--- talk about e2e tests


--- Move comments about react vs rest vs cli etc earlier on, and say "Gonna use react as my examples as I would expect the majority of people here have heard of it if not touched it.
If you check out the deck on my website, I'm going to try and have some examples or references but not really cover them.
-->
      <section data-auto-animate>
        <h2>What is it good for?</h2>
        <h3>Documentation</h3>
        <ul>
          <li>Why does this function return this?</li>
          <li>What does real world input look like?</li>
        </ul>
      </section>
      <section data-auto-animate>
        <h2>What is it good for?</h2>
        <div class="r-stack">
          <div class="fragment current-visible" data-fragment-index="0">
            <h3>Confidence</h3>
            <ul>
              <li>in future changes</li>
              <li>current changes</li>
              <li>refactors</li>
            </ul>
          </div>
          <div class="fragment fade-out" data-fragment-index="0">
            <h3>Documentation</h3>
            <ul>
              <li>Why does this function return this?</li>
              <li>What does real world input look like?</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          Between the time I pitched the talk, and now, I've actually learned that AI coding tools can take advantage
          of
          tests to make sure it doesn't break existing behavior.
        </aside>
      </section>
    </div>
  </div>

  <script src="/assets/reveal/reveal.js"></script>
  <script src="/assets/reveal/plugin/highlight/highlight.js"></script>
  <script src="/assets/reveal/plugin/notes/notes.js"></script>
  <script src="/assets/reveal/plugin/markdown/markdown.js"></script>

  <script>
    Reveal.initialize({
      // view: 'scroll',
      // scrollProgress: true,
      controls: true,
      progress: true,
      history: true,
      slideNumber: false,
      plugins: [RevealNotes, RevealHighlight, RevealMarkdown]
    });
  </script>
</body>

</html>
